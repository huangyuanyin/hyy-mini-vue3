{"version":3,"file":"reactivity.esm-bundler.js","sources":["../../shared/src/index.ts","../src/effect.ts","../src/baseHandlers.ts","../src/reactive.ts"],"sourcesContent":["// 公共方法\r\n\r\nexport function isObject(target) {\r\n  return target !== null && typeof target === 'object'\r\n}\r\n","// 1. 定义effect => effect：在视图中获取数据，触发get，收集依赖，数据发生变化，触发set，通知依赖更新\r\nexport function effect(fn, options: any = {}) {\r\n  const effect = createReactEffect(fn, options) // 2.创建响应式effect\r\n  // 3. 判断是否是立即执行的effect\r\n  if (!options.lazy) {\r\n    effect() // 4.执行effect(默认执行)\r\n  }\r\n  return effect // 6.返回响应式effect\r\n}\r\n\r\nlet uid = 0 // 定义全局变量\r\nlet activeEffect // 定义全局变量 => 用于保存当前的effect\r\nconst effectStack = [] // 定义一个栈 => 用于保存effect => 用于解决effect嵌套的问题\r\n\r\nfunction createReactEffect(fn, options) {\r\n  // 5.创建响应式effect\r\n  const effect = function reactiveEffect() {\r\n    try {\r\n      // 入栈\r\n      effectStack.push(effect) // 3.保存当前的effect\r\n      activeEffect = effect // 1.保存当前的effect\r\n      fn() // 6.执行用户的方法\r\n    } finally {\r\n      // 出栈\r\n      effectStack.pop() // 4.删除当前的effect\r\n      activeEffect = effectStack[effectStack.length - 1] // 保存当前的effect\r\n    }\r\n  }\r\n  effect.id = uid++ // 给effect添加id => 用于区分effect\r\n  effect._isEffect = true // 给effect添加标识 => 用于判断是否是响应式的effect\r\n  effect.raw = fn // 给effect添加原始方法 => 用于保存用户的方法\r\n  effect.options = options // 给effect添加配置项 => 用于保存用户的配置项\r\n  return effect\r\n}\r\n\r\n// 收集依赖 在视图中获取数据，触发get，收集依赖\r\nexport function Track(target, type, key) {\r\n  console.log(target, type, key, activeEffect)\r\n}\r\n\r\n// 问题 (1) effect 是一个树形结构\r\n// effect(() => {\r\n//   // effect1\r\n//   state.name // 收集的effect1\r\n//   effect(() => {\r\n//     // effect2\r\n//     state.age // 收集的effect2\r\n//   })\r\n//   state.a // 收集的effect1\r\n// })\r\n","import { isObject } from '@vue/shared'\r\nimport { Track } from './effect'\r\nimport { TrackOpType } from './operations'\r\nimport { reactive, readonly } from './reactive'\r\n\r\n// state=reactive({name:'zhangsan',age:18})\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n  // target: 目标对象；key: 属性名；receiver: 代理对象\r\n  return function get(target, key, receiver) {\r\n    // 1. 获取属性值\r\n    const res = Reflect.get(target, key, receiver) // Reflect.get() => 获取对象的属性值 => target[key]\r\n    // 2. 判断是否是只读的\r\n    if (!isReadonly) {\r\n      // 如果不是只读的，就进行依赖收集 => 收集依赖，等数据变化后更新视图\r\n      // 收集effect\r\n      // target: 目标对象；type: 操作类型；key: 属性名\r\n      Track(target, TrackOpType.GET, key)\r\n      return res\r\n    }\r\n    // 3. 判断是否是浅的\r\n    if (shallow) {\r\n      return res\r\n    }\r\n    // 4. 判断key是否是对象，如果是对象，就返回代理对象（递归）\r\n    // 重点：懒代理：只有当属性值被取值的时候，才会进行代理（提高了性能优化）\r\n    if (isObject(res)) {\r\n      // 5. 如果是对象，就返回代理对象\r\n      return isReadonly ? readonly(res) : reactive(res) // 递归\r\n    }\r\n    // 6. 返回属性值\r\n    return res\r\n  }\r\n}\r\n\r\n// set方法\r\nfunction createSetter(shallow = false) {\r\n  // target: 目标对象；key: 属性名；value: 属性值；receiver: 代理对象\r\n  return function set(target, key, value, receiver) {\r\n    const res = Reflect.set(target, key, value, receiver) // 获取最新的值 => Reflect.set() => 设置对象的属性值 => target[key] = value\r\n    // Todo: 触发更新\r\n    //返回结果\r\n    return res\r\n  }\r\n}\r\n\r\n// get方法\r\nconst get = createGetter() // 代理对象的get方法 => 不是只读的，是深的，是响应式的\r\nconst shallowGet = createGetter(false, true) // 不是只读的，是浅的，是响应式的\r\nconst readonlyGet = createGetter(true) // 是只读的，是深的，是响应式的\r\nconst shallowReadonlyGet = createGetter(true, true) // 是只读的，是浅的，是响应式的\r\n\r\n// set方法\r\nconst set = createSetter() // 不是只读的，是深的，是响应式的\r\nconst shallowSet = createSetter(true) // 不是只读的，是浅的，是响应式的\r\n\r\nexport const reactiveHandlers = {\r\n  get,\r\n  set\r\n}\r\nexport const shallowReactiveHandlers = {\r\n  get: shallowGet,\r\n  set: shallowSet\r\n}\r\nexport const readonlyHandlers = {\r\n  get: readonlyGet,\r\n  set: (target, key, value) => {\r\n    console.warn('set on key \"xxx\" failed: target is readonly.')\r\n  }\r\n}\r\nexport const shallowReadonlyHandlers = {\r\n  get: shallowReadonlyGet,\r\n  set: (target, key, value) => {\r\n    console.warn('set on key \"xxx\" failed: target is readonly.')\r\n  }\r\n}\r\n\r\n// 柯里化\r\n// let state = { name: '55' }\r\n// new Proxy(state, {\r\n//   get() {},\r\n//   set() {}\r\n// })\r\n// vue2中上来会对data中的数据进行递归的遍历，将所有的数据都变成响应式的数据\r\n// 但是vue3中的proxy => 上来只会对第一层进行代理\r\n","import { isObject } from '@vue/shared'\r\nimport { reactiveHandlers, shallowReactiveHandlers, readonlyHandlers, shallowReadonlyHandlers } from './baseHandlers'\r\n\r\nexport function reactive(target) {\r\n  // target: 目标对象\r\n  // false: 不是只读的`\r\n  // reactiveHandlers: 代理对象\r\n  return createReactiveObject(target, false, reactiveHandlers) // 高阶函数\r\n}\r\n\r\nexport function shallowReactive(target) {\r\n  return createReactiveObject(target, false, shallowReactiveHandlers)\r\n}\r\n\r\nexport function readonly(target) {\r\n  return createReactiveObject(target, true, readonlyHandlers)\r\n}\r\n\r\nexport function shallowReadonly(target) {\r\n  return createReactiveObject(target, true, shallowReadonlyHandlers)\r\n}\r\n/*\r\n  实现代理对象的方法\r\n * 1. target: 目标对象\r\n * 2. isReadonly: 是否只读\r\n * 3. baseHandlers: 基础的handlers\r\n * 4. 返回值：代理对象\r\n */\r\nconst reactiveMap = new WeakMap() // 用来存储已经代理过的对象(防止重复代理) => 使用weakMap的好处（key必须是对象，自动的垃圾回收=>不会造成内存泄漏）\r\nconst readonlyMap = new WeakMap()\r\nfunction createReactiveObject(target, isReadonly, baseHandlers) {\r\n  // 1. 判断target是否是对象\r\n  if (!isObject(target)) {\r\n    return target\r\n  }\r\n  // 核心：Proxy\r\n  // 问题优化：如果目标对象已经被代理过了，就不要再次代理了\r\n  const proxyMap = isReadonly ? readonlyMap : reactiveMap // 代理对象的map\r\n  const proxyEs = proxyMap.get(target) // 代理对象\r\n  // 如果已经代理过了，就直接返回代理对象\r\n  if (proxyEs) {\r\n    return proxyEs\r\n  }\r\n  const proxy = new Proxy(target, baseHandlers) // proxy => 代理对象(参数一：目标对象，参数二：代理对象) baseHandlers => 处理拦截的对象 {get,set}\r\n  // 将代理对象存储起来\r\n  proxyMap.set(target, proxy)\r\n  return proxy\r\n}\r\n\r\n// 4个方法：（1）是不是只读的（2）是不是浅的（代理的时候需不需要嵌套多层）（3）是不是响应式的（4）是不是只读的响应式的\r\n// 注意：4个方法的核心是proxy => 源码中 采用的是高阶函数中的科里化函数（根据不同的参数来进行处理）\r\n"],"names":[],"mappings":"AAAA;AAEM,SAAU,QAAQ,CAAC,MAAM,EAAA;IAC7B,OAAO,MAAM,KAAK,IAAI,IAAI,OAAO,MAAM,KAAK,QAAQ,CAAA;AACtD;;ACJA;SACgB,MAAM,CAAC,EAAE,EAAE,UAAe,EAAE,EAAA;IAC1C,MAAM,MAAM,GAAG,iBAAiB,CAAC,EAAE,EAAE,OAAO,CAAC,CAAA;;AAE7C,IAAA,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE;QACjB,MAAM,EAAE,CAAA;AACT,KAAA;IACD,OAAO,MAAM,CAAA;AACf,CAAC;AAED,IAAI,GAAG,GAAG,CAAC,CAAA;AACX,IAAI,YAAY,CAAA;AAChB,MAAM,WAAW,GAAG,EAAE,CAAA;AAEtB,SAAS,iBAAiB,CAAC,EAAE,EAAE,OAAO,EAAA;;IAEpC,MAAM,MAAM,GAAG,SAAS,cAAc,GAAA;QACpC,IAAI;;AAEF,YAAA,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;AACxB,YAAA,YAAY,GAAG,MAAM,CAAA;YACrB,EAAE,EAAE,CAAA;AACL,SAAA;AAAS,gBAAA;;AAER,YAAA,WAAW,CAAC,GAAG,EAAE,CAAA;YACjB,YAAY,GAAG,WAAW,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,CAAA;AACnD,SAAA;AACH,KAAC,CAAA;AACD,IAAA,MAAM,CAAC,EAAE,GAAG,GAAG,EAAE,CAAA;AACjB,IAAA,MAAM,CAAC,SAAS,GAAG,IAAI,CAAA;AACvB,IAAA,MAAM,CAAC,GAAG,GAAG,EAAE,CAAA;AACf,IAAA,MAAM,CAAC,OAAO,GAAG,OAAO,CAAA;AACxB,IAAA,OAAO,MAAM,CAAA;AACf,CAAC;AAED;SACgB,KAAK,CAAC,MAAM,EAAE,IAAI,EAAE,GAAG,EAAA;IACrC,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE,YAAY,CAAC,CAAA;AAC9C,CAAC;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA,SAAS,YAAY,CAAC,UAAU,GAAG,KAAK,EAAE,OAAO,GAAG,KAAK,EAAA;;AAEvD,IAAA,OAAO,SAAS,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,QAAQ,EAAA;;AAEvC,QAAA,MAAM,GAAG,GAAG,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,QAAQ,CAAC,CAAA;;QAE9C,IAAI,CAAC,UAAU,EAAE;;;;AAIf,YAAA,KAAK,CAAC,MAAM,EAAmB,CAAA,wBAAA,GAAG,CAAC,CAAA;AACnC,YAAA,OAAO,GAAG,CAAA;AACX,SAAA;;AAED,QAAA,IAAI,OAAO,EAAE;AACX,YAAA,OAAO,GAAG,CAAA;AACX,SAAA;;;AAGD,QAAA,IAAI,QAAQ,CAAC,GAAG,CAAC,EAAE;;AAEjB,YAAA,OAAO,UAAU,GAAG,QAAQ,CAAC,GAAG,CAAC,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAA;AAClD,SAAA;;AAED,QAAA,OAAO,GAAG,CAAA;AACZ,KAAC,CAAA;AACH,CAAC;AAED;AACA,SAAS,YAAY,CAAC,OAAO,GAAG,KAAK,EAAA;;IAEnC,OAAO,SAAS,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,QAAQ,EAAA;AAC9C,QAAA,MAAM,GAAG,GAAG,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAA;;;AAGrD,QAAA,OAAO,GAAG,CAAA;AACZ,KAAC,CAAA;AACH,CAAC;AAED;AACA,MAAM,GAAG,GAAG,YAAY,EAAE,CAAA;AAC1B,MAAM,UAAU,GAAG,YAAY,CAAC,KAAK,EAAE,IAAI,CAAC,CAAA;AAC5C,MAAM,WAAW,GAAG,YAAY,CAAC,IAAI,CAAC,CAAA;AACtC,MAAM,kBAAkB,GAAG,YAAY,CAAC,IAAI,EAAE,IAAI,CAAC,CAAA;AAEnD;AACA,MAAM,GAAG,GAAG,YAAY,EAAE,CAAA;AAC1B,MAAM,UAAU,GAAG,YAAY,CAAC,IAAI,CAAC,CAAA;AAE9B,MAAM,gBAAgB,GAAG;IAC9B,GAAG;IACH,GAAG;CACJ,CAAA;AACM,MAAM,uBAAuB,GAAG;AACrC,IAAA,GAAG,EAAE,UAAU;AACf,IAAA,GAAG,EAAE,UAAU;CAChB,CAAA;AACM,MAAM,gBAAgB,GAAG;AAC9B,IAAA,GAAG,EAAE,WAAW;IAChB,GAAG,EAAE,CAAC,MAAM,EAAE,GAAG,EAAE,KAAK,KAAI;AAC1B,QAAA,OAAO,CAAC,IAAI,CAAC,8CAA8C,CAAC,CAAA;KAC7D;CACF,CAAA;AACM,MAAM,uBAAuB,GAAG;AACrC,IAAA,GAAG,EAAE,kBAAkB;IACvB,GAAG,EAAE,CAAC,MAAM,EAAE,GAAG,EAAE,KAAK,KAAI;AAC1B,QAAA,OAAO,CAAC,IAAI,CAAC,8CAA8C,CAAC,CAAA;KAC7D;CACF,CAAA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChFM,SAAU,QAAQ,CAAC,MAAM,EAAA;;;;IAI7B,OAAO,oBAAoB,CAAC,MAAM,EAAE,KAAK,EAAE,gBAAgB,CAAC,CAAA;AAC9D,CAAC;AAEK,SAAU,eAAe,CAAC,MAAM,EAAA;IACpC,OAAO,oBAAoB,CAAC,MAAM,EAAE,KAAK,EAAE,uBAAuB,CAAC,CAAA;AACrE,CAAC;AAEK,SAAU,QAAQ,CAAC,MAAM,EAAA;IAC7B,OAAO,oBAAoB,CAAC,MAAM,EAAE,IAAI,EAAE,gBAAgB,CAAC,CAAA;AAC7D,CAAC;AAEK,SAAU,eAAe,CAAC,MAAM,EAAA;IACpC,OAAO,oBAAoB,CAAC,MAAM,EAAE,IAAI,EAAE,uBAAuB,CAAC,CAAA;AACpE,CAAC;AACD;;;;;;AAMG;AACH,MAAM,WAAW,GAAG,IAAI,OAAO,EAAE,CAAA;AACjC,MAAM,WAAW,GAAG,IAAI,OAAO,EAAE,CAAA;AACjC,SAAS,oBAAoB,CAAC,MAAM,EAAE,UAAU,EAAE,YAAY,EAAA;;AAE5D,IAAA,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE;AACrB,QAAA,OAAO,MAAM,CAAA;AACd,KAAA;;;AAGD,IAAA,MAAM,QAAQ,GAAG,UAAU,GAAG,WAAW,GAAG,WAAW,CAAA;IACvD,MAAM,OAAO,GAAG,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,CAAA;;AAEpC,IAAA,IAAI,OAAO,EAAE;AACX,QAAA,OAAO,OAAO,CAAA;AACf,KAAA;IACD,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,MAAM,EAAE,YAAY,CAAC,CAAA;;AAE7C,IAAA,QAAQ,CAAC,GAAG,CAAC,MAAM,EAAE,KAAK,CAAC,CAAA;AAC3B,IAAA,OAAO,KAAK,CAAA;AACd,CAAC;AAED;AACA;;;;"}